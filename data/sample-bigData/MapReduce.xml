<?xml version="1.0" ?><page xmlns="http://www.mediawiki.org/xml/export-0.8/" version="0.8">
    <title>MapReduce</title>
    <ns>0</ns>
    <id>1702875</id>
    <revision>
      <id>562910751</id>
      <parentid>562889646</parentid>
      <timestamp>2013-07-05T01:03:53Z</timestamp>
      <contributor>
        <username>Mindmatrix</username>
        <id>160367</id>
      </contributor>
      <minor></minor>
      <comment>[[Help:Reverting|Reverted]] edits by [[Special:Contributions/62.83.247.5|62.83.247.5]] ([[User talk:62.83.247.5|talk]]) to last version by 134.174.174.181</comment>
      <text xml:space="preserve">'''MapReduce''' is a [[programming model]] for processing large data sets with a [[Parallel computing|parallel]], [[distributed computing|distributed]] algorithm on a [[Cluster (computing)|cluster]].&lt;ref&gt;[http://news.cnet.com/8301-10784_3-9955184-7.html Google spotlights data center inner workings | Tech news blog - CNET News.com&lt;!-- Bot generated title --&gt;]&lt;/ref&gt;

A MapReduce program comprises a '''Map()''' procedure that performs filtering and sorting (such as sorting students by first name into queues, one queue for each name) and a '''Reduce()''' procedure that performs a summary operation (such as counting the number of students in each queue, yielding name frequencies). The "MapReduce System" (also called "infrastructure", "framework") orchestrates by marshaling the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, providing for [[Redundancy (engineering)|redundancy]] and [[Fault-tolerant computer system|failures]], and overall management of the whole process.

The model is inspired by the [[map (higher-order function)|map]] and [[fold (higher-order function)|reduce]] functions commonly used in [[functional programming]],&lt;ref name="map"&gt;"Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages." -[http://research.google.com/archive/mapreduce.html "MapReduce: Simplified Data Processing on Large Clusters"], by Jeffrey Dean and Sanjay Ghemawat; from [[Google Research]]&lt;/ref&gt; although their purpose in the MapReduce framework is not the same as their original forms.&lt;ref&gt;[http://userpages.uni-koblenz.de/~laemmel/MapReduce/paper.pdf "Google's MapReduce Programming Model -- Revisited"] — paper by Ralf Lämmel; from [[Microsoft]]&lt;/ref&gt;

MapReduce [[library (software)|libraries]] have been written in many programming languages. A popular [[free software|free]] implementation is [[Apache Hadoop]]. The name MapReduce originally referred to the proprietary [[Google]] technology and has since been [[generic trademark|genericized]].

==Overview==

&lt;!-- Deleted image removed: [[Image:MapReduce Overview Poske.png|right|thumb|400px|MapReduce Overview.]] --&gt;
MapReduce is a framework for processing [[Parallel computing|parallelizable]] problems across huge datasets using a large number of computers (nodes), collectively referred to as a [[Computer cluster|cluster]] (if all nodes are on the same local network and use similar hardware) or a [[Grid Computing|grid]] (if the nodes are shared across geographically and administratively distributed systems, and use more heterogenous hardware). Computational processing can occur on data stored either in a [[filesystem]] (unstructured) or in a [[database]] (structured).  MapReduce can take advantage of locality of data, processing data on or near the storage assets to decrease transmission of data. 

'''"Map" step:''' The master node takes the input, divides it into smaller sub-problems, and distributes them to worker nodes. A worker node may do this again in turn, leading to a multi-level [[Tree (data structure)|tree]] structure. The worker node processes the smaller problem, and passes the answer back to its master node.

'''"Reduce" step:''' The master node then collects the answers to all the sub-problems and combines them in some way to form the output&amp;nbsp;&amp;ndash; the answer to the problem it was originally trying to solve.

MapReduce allows for distributed processing of the map and reduction operations. Provided each mapping operation is independent of the others, all maps can be performed in parallel&amp;nbsp;&amp;ndash; though in practice it is limited by the number of independent data sources and/or the number of CPUs near each source. Similarly, a set of 'reducers' can perform the reduction phase - provided all outputs of the map operation that share the same key are presented to the same reducer at the same time, or if the reduction function is [[Associative property|associative]].  While this process can often appear inefficient compared to algorithms that are more sequential, MapReduce can be applied to significantly larger datasets than "commodity" servers can handle&amp;nbsp;&amp;ndash; a large [[server farm]] can use MapReduce to sort a [[petabyte]] of data in only a few hours. The parallelism also offers some possibility of recovering from partial failure of servers or storage during the operation: if one mapper or reducer fails, the work can be rescheduled&amp;nbsp;&amp;ndash; assuming the input data is still available.

Another way to look at MapReduce is as a 5-step parallel and distributed computation:

# '''Prepare the Map() input''' – the "MapReduce system" designates Map processors, assigns the K1 input key value each processor would work on, and provides that processor with all the input data associated with that key value.
# '''Run the user-provided Map() code''' – Map() is run exactly once for each K1 key value, generating output organized by key values K2.
# '''"Shuffle" the Map output to the Reduce processors''' – the MapReduce system designates Reduce processors, assigns the K2 key value each processor would work on, and provides that processor with all the Map-generated data associated with that key value.
# '''Run the user-provided Reduce() code''' – Reduce() is run exactly once for each K2 key value produced by the Map step.
# '''Produce the final output''' – the MapReduce system collects all the Reduce output, and sorts it by K2 to produce the final outcome.

Logically these 5 steps can be thought of as running in sequence – each step starts only after the previous step is completed – though in practice, of course, they can be intertwined, as long as the final result is not affected.

In many situations the input data might already be distributed ([[Shard (database architecture)|"sharded"]]) among many different servers, in which case step 1 could sometimes be greatly simplified by assigning Map servers that would process the locally present input data.  Similarly, step 3 could sometimes be sped up by assigning Reduce processors that are as much as possible local to the Map-generated data they need to process.

==Logical view==
The  ''Map'' and ''Reduce'' functions of ''MapReduce'' are both defined with respect to data structured in (key, value) pairs. ''Map'' takes one pair of data with a type in one [[data domain]], and returns a list of pairs in a different domain:
&lt;code&gt;Map(k1,v1)&lt;/code&gt; → &lt;code&gt;list(k2,v2)&lt;/code&gt;

The ''Map'' function is applied in parallel to every pair in the input dataset. This produces a list of pairs for each call.
After that, the MapReduce framework collects all pairs with the same key from all lists and groups them together, creating one group for each key.

The ''Reduce'' function is then applied in parallel to each group, which in turn produces a collection of values in the same domain:

&lt;code&gt;Reduce(k2, list (v2))&lt;/code&gt; → &lt;code&gt;list(v3)&lt;/code&gt;

Each ''Reduce'' call typically produces either one value v3 or an empty return, though one call is allowed to return more than one value. The returns of all calls are collected as the desired result list.

Thus the MapReduce framework transforms a list of (key, value) pairs into a list of values. This behavior is different from the typical functional programming map and reduce combination, which accepts a list of arbitrary values and returns one single value that combines ''all'' the values returned by map.

It is [[Necessity and sufficiency|necessary but not sufficient]] to have implementations of the map and reduce abstractions in order to implement MapReduce. Distributed implementations of MapReduce require a means of connecting the processes performing the Map and Reduce phases. This may be a [[distributed file system]]. Other options are possible, such as direct streaming from mappers to reducers, or for the mapping processors to serve up their results to reducers that query them.

===Examples===
{{see also|Talk:MapReduce#Alternative example}}

The prototypical MapReduce example counts the appearance of each word in a set of documents:&lt;ref&gt;http://research.google.com/archive/mapreduce-osdi04-slides/index-auto-0004.html&lt;/ref&gt;

&lt;source lang='c'&gt;
function map(String name, String document):
  // name: document name
  // document: document contents
  for each word w in document:
    emit (w, 1)

function reduce(String word, Iterator partialCounts):
  // word: a word
  // partialCounts: a list of aggregated partial counts
  sum = 0
  for each pc in partialCounts:
    sum += ParseInt(pc)
  emit (word, sum)
&lt;/source&gt;

Here, each document is split into words, and each word is counted by the ''map'' function, using the word as the result key. The framework puts together all the pairs with the same key and feeds them to the same call to ''reduce'', thus this function just needs to sum all of its input values to find the total appearances of that word.

As another example, imagine that for a database of 1.1 billion people, one would like to compute the average number of social contacts a person has according to age.  In [[SQL]] such a query could be expressed as:

&lt;source lang="sql"&gt;
SELECT age AS Y, AVG(contacts) AS A
FROM social.person GROUP BY age ORDER BY age
&lt;/source&gt;

Using MapReduce, the &lt;tt&gt;K1&lt;/tt&gt; key values could be the integers 1 through 1,100, each representing a batch of 1 million records, the &lt;tt&gt;K2&lt;/tt&gt; key value could be a person’s age in years, and this computation could be achieved using the following functions:

 '''function''' Map '''is'''
     '''input:''' '''integer''' K1 between 1 and 1100, representing a batch of 1 million social.person records
     '''for each''' social.person record in the K1 batch '''do'''
         '''let''' Y be the person's age
         '''let''' N be the number of contacts the person has
         '''produce one output record''' &lt;Y,N&gt;
     '''repeat'''
 '''end function'''
 
 '''function''' Reduce '''is'''
     '''input:''' age (in years) Y
     '''for each''' input record &lt;Y,N&gt; '''do'''
         Accumulate in S the sum of N
         Accumulate in C the count of records so far
     '''repeat'''
     '''let''' A be S/C
     '''produce one output record''' &lt;Y,A&gt;
 '''end function'''

The MapReduce System would line up the 1,100 Map processors, and would provide each with its corresponding 1 million input records.  The Map step would produce 1.1 billion &lt;tt&gt;&lt;Y,N&gt;&lt;/tt&gt; records, with &lt;tt&gt;Y&lt;/tt&gt; values ranging between, say, 8 and 103.  The MapReduce System would then line up the 96 Reduce processors by performing shuffling operation of the key/value pairs due to the fact that we need average per age, and provide each with its millions of corresponding input records.  The Reduce step would result in the much reduced set of only 96 output records &lt;tt&gt;&lt;Y,A&gt;&lt;/tt&gt;, which would be put in the final result file, sorted by &lt;tt&gt;Y&lt;/tt&gt;.

==Dataflow==
The frozen part of the MapReduce framework is a large distributed sort. The hot spots, which the application defines, are:
* an ''input reader''
* a ''Map'' function
* a ''partition'' function
* a ''compare'' function
* a ''Reduce'' function
* an ''output writer''

===Input reader===
The ''input reader'' divides the input into appropriate size 'splits' (in practice typically 16&amp;nbsp;MB to 128&amp;nbsp;MB) and the framework assigns one split to each ''Map'' function. The ''input reader'' reads data from stable storage (typically a [[distributed file system]]) and generates key/value pairs.

A common example will read a directory full of text files and return each line as a record.

===Map function===
The ''Map'' function takes a series of key/value pairs, processes each, and generates zero or more output key/value pairs. The input and output types of the map can be (and often are) different from each other.

If the application is doing a word count, the map function would break the line into words and output a key/value pair for each word.  Each output pair would contain the word as the key and the number of instances of that word in the line as the value.

===Partition function===
Each ''Map'' function output is allocated to a particular ''reducer'' by the application's ''partition'' function for [[sharding]] purposes. The ''partition'' function is given the key and the number of reducers and returns the index of the desired ''reduce''.

A typical default is to [[Hash function|hash]] the key and use the hash value [[Modulo operation|modulo]] the number of ''reducers''.  It is important to pick a partition function that gives an approximately uniform distribution of data per shard for [[load balancing (computing)|load-balancing]] purposes, otherwise the MapReduce operation can be held up waiting for slow reducers 
(reducers assigned more than their share of data) to finish.

Between the map and reduce stages, the data is ''shuffled'' (parallel-sorted / exchanged between nodes) in order to move the data from the map node that produced it to the shard in which it will be reduced.  The shuffle can sometimes take longer than the computation time depending on network bandwidth, CPU speeds, data produced and time taken by map and reduce computations.

===Comparison function===
The input for each ''Reduce'' is pulled from the machine where the ''Map'' ran and sorted using the application's ''comparison'' function.

===Reduce function===
The framework calls the application's ''Reduce'' function once for each unique key in the sorted order. The ''Reduce'' can iterate through the values that are associated with that key and produce zero or more outputs.

In the word count example, the ''Reduce'' function takes the input values, sums them and generates a single output of the word and the final sum.

===Output writer===
The ''Output Writer'' writes the output of the ''Reduce'' to the stable storage, usually a [[distributed file system]].

==Distribution and reliability==
MapReduce achieves reliability by parceling out a number of operations on the set of data to each node in the network. Each node is expected to report back periodically with completed work and status updates. If a node falls silent for longer than that interval, the master node (similar to the master server in the [[Google File System]]) records the node as dead and sends out the node's assigned work to other nodes. Individual operations use [[atomicity (programming)|atomic]] operations for naming file outputs as a check to ensure that there are not parallel conflicting threads running. When files are renamed, it is possible to also copy them to another name in addition to the name of the task (allowing for [[Side-effect (computer science)|side-effects]]).

The reduce operations operate much the same way. Because of their inferior properties with regard to parallel operations, the master node attempts to schedule reduce operations on the same node, or in the same rack as the node holding the data being operated on. This property is desirable as it conserves bandwidth across the backbone network of the datacenter.

Implementations are not necessarily highly reliable. For example, in older versions of [[Hadoop]] the ''NameNode'' was a [[single point of failure]] for the distributed filesystem.  Later versions of Hadoop have high availability with an active/passive failover for the "NameNode."

==Uses==
MapReduce is useful in a wide range of applications, including distributed pattern-based searching, distributed sorting, web link-graph reversal, term-vector per host, web access log stats, [[inverted index]] construction, document clustering, [[machine learning]],&lt;ref name="mrml"&gt;{{cite web| url=http://www.willowgarage.com/map-reduce-machine-learning-multicore| title=Map-Reduce for Machine Learning on Multicore| author=[[Cheng-Tao Chu]]| coauthors=Sang Kyun Kim, Yi-An Lin, YuanYuan Yu, Gary Bradski, Andrew Ng, and [[Kunle Olukotun]]| publisher=NIPS 2006}}&lt;/ref&gt; and [[statistical machine translation]]. Moreover, the MapReduce model has been adapted to several computing environments like multi-core and many-core systems,&lt;ref name="evalMR"&gt;{{cite web| url=http://www.willowgarage.com/evaluating-mapreduce-multi-core-and-multiprocessor-systems| title=Evaluating MapReduce for Multi-core and Multiprocessor Systems| author=[[Colby Ranger]]| coauthors=Ramanan Raghuraman, Arun Penmetsa, Gary Bradski, and Christos Kozyrakis| publisher=HPCA 2007, Best Paper}}&lt;/ref&gt;&lt;ref name="graphicsMR"&gt;{{cite web| url=http://portal.acm.org/citation.cfm?id=1454152| title=Mars: a MapReduce framework on graphics processors| author=Bingsheng He, Wenbin Fang, Qiong Luo, Naga K. Govindaraju, Tuyong Wang | publisher=PACT'08}}&lt;/ref&gt;&lt;ref name="tiledMR"&gt;{{cite web| url=http://ipads.se.sjtu.edu.cn/lib/exe/fetch.php?media=publications:ostrich-pact10.pdf| title=Tiled-MapReduce: Optimizing Resource Usages of Data-parallel Applications on Multicore with Tiling| author= Rong Chen, Haibo Chen, and Binyu Zang | publisher=PACT'10}}&lt;/ref&gt; desktop grids,&lt;ref name="gridMR"&gt;{{cite web| url=http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5662789| title=Towards MapReduce for Desktop Grid Computing| author=Bing Tang, Moca, M., Chevalier, S., Haiwu He and Fedak, G.| publisher=3PGCIC'10}}&lt;/ref&gt; volunteer computing environments,&lt;ref name="volunteerMR"&gt;{{cite web| url=http://portal.acm.org/citation.cfm?id=1851489| title=MOON: MapReduce On Opportunistic eNvironments| author=Heshan Lin, Xiaosong Ma, Jeremy Archuleta, Wu-chun Feng, Mark Gardner, Zhe Zhang| publisher=HPDC'10}}&lt;/ref&gt; dynamic cloud environments,&lt;ref name="dynCloudMR"&gt;{{cite web| url=http://www.sciencedirect.com/science/article/pii/S0022000011001668| title=P2P-MapReduce: Parallel data processing in dynamic Cloud environments| author=Fabrizio Marozzo, Domenico Talia, Paolo Trunfio| publisher=In: Journal of Computer and System Sciences, vol. 78, n. 5, pp. 1382--1402, Elsevier Science, September 2012}}&lt;/ref&gt; and mobile environments.&lt;ref name="mobileMR"&gt;{{cite web| url=http://portal.acm.org/citation.cfm?id=1839332| title=Misco: a MapReduce framework for mobile systems| author=Adam Dou, Vana Kalogeraki, Dimitrios Gunopulos, Taneli Mielikainen and Ville H. Tuulos  | publisher=HPDC'10}}&lt;/ref&gt; 

At Google, MapReduce was used to completely regenerate Google's index of the [[World Wide Web]]. It replaced the old ''ad hoc'' programs that updated the index and ran the various analyses.&lt;ref name="usage"&gt;{{cite web| quote=As of October, Google was running about 3,000 computing jobs per day through MapReduce, representing thousands of machine-days, according to a presentation by Dean. Among other things, these batch routines analyze the latest Web pages and update Google's indexes.| url=http://www.baselinemag.com/article2/0,1540,1985048,00.asp| title=How Google Works| publisher=baselinemag.com}}&lt;/ref&gt;

MapReduce's stable inputs and outputs are usually stored in a [[distributed file system]]. The transient data is usually stored on local disk and fetched remotely by the reducers.

==Criticism==
[[David DeWitt]] and [[Michael Stonebraker]], computer scientists specializing in [[parallel database]]s and [[shared-nothing architecture]]s, have been critical of the breadth of problems that MapReduce can be used for.&lt;ref name="shark"&gt;{{cite web| url=http://typicalprogrammer.com/?p=16| title=Database Experts Jump the MapReduce Shark}}&lt;/ref&gt; They called its interface too low-level and questioned whether it really represents the [[paradigm shift]] its proponents have claimed it is.&lt;ref name="ddandms1"&gt;{{cite web| url=http://craig-henderson.blogspot.com/2009/11/dewitt-and-stonebrakers-mapreduce-major.html| title=MapReduce: A major step backwards| author=[[David DeWitt]]| coauthors=[[Michael Stonebraker]]| publisher=craig-henderson.blogspot.com| accessdate=2008-08-27}}&lt;/ref&gt; They challenged the MapReduce proponents' claims of novelty, citing [[Teradata]] as an example of [[prior art]] that has existed for over two decades. They also compared MapReduce programmers to [[CODASYL|Codasyl]] programmers, noting both are "writing in a [[Low-level programming language|low-level language]] performing low-level record manipulation."&lt;ref name="ddandms1"/&gt; MapReduce's use of input files and lack of [[Logical schema|schema]] support prevents the performance improvements enabled by common database system features such as [[B-tree]]s and [[Partition (database)|hash partitioning]], though projects such as [[Pig (programming language)|Pig (or PigLatin)]], [[Sawzall (programming language)|Sawzall]], [[Apache Hive]],&lt;ref name="ApacheHiveWiki"&gt;{{cite web| url=https://cwiki.apache.org/confluence/display/Hive/Home| title=Apache Hive - Index of - Apache Software Foundation}}&lt;/ref&gt; [http://ysmart.cse.ohio-state.edu/ YSmart],&lt;ref name="YSmartPaper"&gt;{{cite web| url=http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-11-7.pdf| title=YSmart: Yet Another SQL-to-MapReduce Translator| author=Rubao Lee, Tian Luo, Yin Huai, Fusheng Wang, Yongqiang He and Xiaodong Zhang|format=PDF}}&lt;/ref&gt; [[HBase]]&lt;ref name="HBase"&gt;{{cite web| url=http://hbase.apache.org/| title=HBase - HBase Home - Apache Software Foundation}}&lt;/ref&gt; and [[BigTable]]&lt;ref name="HBase"/&gt;&lt;ref name="BigTablePaper"&gt;{{cite web| url=http://research.google.com/archive/bigtable-osdi06.pdf| title=Bigtable: A Distributed Storage System for Structured Data| format=PDF}}&lt;/ref&gt; are addressing some of these problems.

Greg Jorgensen wrote an article rejecting these views.&lt;ref name="gj1"&gt;{{cite web| url=http://typicalprogrammer.com/?p=16| title=Relational Database Experts Jump The MapReduce Shark| author=[[Greg Jorgensen]] | publisher=typicalprogrammer.com| accessdate=2009-11-11}}&lt;/ref&gt; Jorgensen asserts that DeWitt and Stonebraker's entire analysis is groundless as MapReduce was never designed nor intended to be used as a database.

DeWitt and Stonebraker have subsequently published a detailed benchmark study in 2009 comparing performance of [[Hadoop|Hadoop's]] MapReduce and [[RDBMS]] approaches on several specific problems.&lt;ref name="sigmod"&gt;{{cite web| url=http://database.cs.brown.edu/projects/mapreduce-vs-dbms/| title=A Comparison of Approaches to Large-Scale Data Analysis| author=Andrew Pavlo| coauthors=E. Paulson, A. Rasin, D. J. Abadi, [[David DeWitt|D. J. Dewitt]], S. Madden, and [[Michael Stonebraker|M. Stonebraker]]| publisher=Brown University| accessdate=2010-01-11}}&lt;/ref&gt; They concluded that relational databases offer real advantages for many kinds of data use, especially on complex processing or where the data is used across an enterprise, but that MapReduce may be easier for users to adopt for simple or one-time processing tasks.

Google has been granted a patent on MapReduce.&lt;ref name="patent"&gt;[http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/PTO/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=7,650,331.PN.&amp;OS=PN/7,650,331&amp;RS=PN/7,650,331 US Patent 7,650,331: "System and method for efficient large-scale data processing "]&lt;/ref&gt; However, there have been claims that this patent should not have been granted because MapReduce is too similar to existing products. For example, map and reduce functionality can be very easily implemented in [[Oracle database|Oracle's]] [[PL/SQL]] database oriented language.&lt;ref name="Curt Monash"&gt;{{cite web| url=http://www.dbms2.com/2010/02/11/google-mapreduce-patent/| title=More patent nonsense — Google MapReduce| author=[[Curt Monash]] | publisher=dbms2.com| accessdate=2010-03-07}}&lt;/ref&gt;

==Conferences and users groups==
* [http://graal.ens-lyon.fr/mapreduce/ The First International Workshop on MapReduce and its Applications (MAPREDUCE'10) ] was held  with the HPDC conference and OGF'29 meeting in Chicago, IL.
* [http://mapreduce.meetup.com/ MapReduce Users Groups ] around the world.

==See also==
* [[Hadoop]], [[Apache Software Foundation|Apache]]'s free and open source implementation of MapReduce.
* [[Pentaho]] - Open source data integration (Kettle), analytics, reporting, visualization and predictive analytics directly from Hadoop nodes
* [[Nutch]] - An effort to build an open source search engine based on [[Lucene]] and Hadoop, also created by Doug Cutting
* [[Datameer]] Analytics Solution (DAS) - data source integration, storage, analytics engine and visualization
* [[Apache Accumulo]] - Secure Big Table
* [[HBase]] - [[BigTable]]-model database
* [[Hypertable]] - HBase alternative
* [[Apache Cassandra]] - A column-oriented database that supports access from Hadoop
* [[HPCC]] - [[LexisNexis]] Risk Solutions High Performance Computing Cluster
* [[Sector/Sphere]] - Open source distributed storage and processing
* [[Cloud computing]]
* [[Big data]]
* [[Data Intensive Computing]]
* [[Algorithmic skeleton]] - A high-level parallel programming model for parallel and distributed computing
* [[MongoDB]] - A [[scalable]], high-performance, [[open source]] [[NoSQL]] [[database]]
* [http://mapreduce.sandia.gov/index.html MapReduce-MPI] MapReduce-MPI Library
* [[Programming with Big Data in R]]

==References==
Specific references:
{{Reflist}}
General references:
{{Refbegin}}
* Dean, Jeffrey &amp; Ghemawat, Sanjay (2004). [http://research.google.com/archive/mapreduce.html "MapReduce: Simplified Data Processing on Large Clusters"]. Retrieved Nov. 23, 2011.
* Matt WIlliams (2009). [http://wordflows.com/matt/2009/01/18/understanding-mapreduce/ "Understanding Map-Reduce"]. Retrieved Apr. 13, 2011.
{{Refend}}

==External links==
{{Commons category}}
; Papers
{{Refbegin}}
*[http://link.springer.com/chapter/10.1007%2F978-3-642-37015-1_6 "CloudSVM: Training an SVM Classifier in Cloud Computing Systems"]-paper by F. Ozgur Catak, M. Erdal Balaban, Springer, Lecture Notes in Computer Science,Pervasive Computing and Networked World 2012 from [[TÜBİTAK]] and [[Istanbul University]] 
* [http://dl.acm.org/citation.cfm?id=1996023.1996026 "A Hierarchical Framework for Cross-Domain MapReduce Execution"] — paper by Yuan Luo, Zhenhua Guo, Yiming Sun, Beth Plale, Judy Qiu; from [[Indiana University]] and Wilfred Li; from [[University of California, San Diego]]
* [http://research.google.com/archive/sawzall.html "Interpreting the Data: Parallel Analysis with Sawzall"] — paper by Rob Pike, Sean Dorward, Robert Griesemer, Sean Quinlan; from [[Google Labs]]
* [http://csl.stanford.edu/%7Echristos/publications/2007.cmp_mapreduce.hpca.pdf "Evaluating MapReduce for Multi-core and Multiprocessor Systems"] — paper by Colby Ranger, Ramanan Raghuraman, Arun Penmetsa, Gary Bradski, and Christos Kozyrakis; from [[Stanford University]]
* [http://www.dbms2.com/2008/08/26/why-mapreduce-matters-to-sql-data-warehousing/ "Why MapReduce Matters to SQL Data Warehousing"] — analysis related to the August, 2008 introduction of MapReduce/SQL integration by [[Aster Data Systems]] and [[Greenplum]]
* [http://pages.cs.wisc.edu/~dekruijf/docs/mapreduce-cell.pdf "MapReduce for the Cell B.E. Architecture"] — paper by Marc de Kruijf and Karthikeyan Sankaralingam; from [[University of Wisconsin–Madison]]
* [http://www.cse.ust.hk/catalac/users/saven/GPGPU/MapReduce/PACT08/171.pdf "Mars: A MapReduce Framework on Graphics Processors"] — paper by Bingsheng He, Wenbin Fang, Qiong Luo, Naga K. Govindaraju, Tuyong Wang; from [[Hong Kong University of Science and Technology]]; published in Proc. PACT 2008. It presents the design and implementation of MapReduce on graphics processors.
* [http://www.springerlink.com/content/h17r882710314147/ "A Peer-to-Peer Framework for Supporting MapReduce Applications in Dynamic Cloud Environments"] — paper by Fabrizio Marozzo, Domenico Talia, Paolo Trunfio; from [[University of Calabria]]; published in Cloud Computing: Principles, Systems and Applications, N. Antonopoulos, L. Gillam (Editors), chapt. 7, pp.&amp;nbsp;113–125, Springer, 2010, ISBN 978-1-84996-240-7.
* [http://portal.acm.org/citation.cfm?doid=1247480.1247602 "Map-Reduce-Merge: Simplified Relational Data Processing on Large Clusters"] — paper by Hung-Chih Yang, Ali Dasdan, Ruey-Lung Hsiao, and D. Stott Parker; from [[Yahoo]] and [[UCLA]]; published in Proc. of ACM SIGMOD, pp.&amp;nbsp;1029–1040, 2007. (This paper shows how to extend MapReduce for relational data processing.)
* FLuX: the [http://citeseer.ist.psu.edu/647742.html Fault-tolerant], [http://citeseer.ist.psu.edu/546646.html Load Balancing] eXchange operator  from [[UC Berkeley]]  provides an integration of partitioned parallelism with process pairs.  This results in a more pipelined approach than Google's MapReduce with instantaneous failover, but with additional implementation cost.
* [http://infolab.stanford.edu/~ullman/pub/mapred.pdf "A New Computation Model for Rack-Based Computing"] — paper by Foto N. Afrati; Jeffrey D. Ullman; from [[Stanford University]]; Not published as of Nov 2009. This paper is an attempt to develop a general model in which one can compare algorithms for computing in an environment similar to what map-reduce expects.
* [http://portal.acm.org/beta/citation.cfm?id=1723112.1723129 FPMR: MapReduce framework on FPGA]—paper by Yi Shan, Bo Wang, Jing Yan, Yu Wang, Ningyi Xu, Huazhong Yang (2010), in FPGA '10, Proceedings of the 18th annual ACM/SIGDA international symposium on Field programmable gate arrays.
* [http://ipads.se.sjtu.edu.cn/lib/exe/fetch.php?media=publications:ostrich-pact10.pdf "Tiled-MapReduce: Optimizing Resource Usages of Data-parallel Applications on Multicore with Tiling"]—paper by Rong Chen, Haibo Chen and Binyu Zang from [[Fudan University]]; published in Proc. PACT 2010. It presents the Tiled-MapReduce programming model which optimizes resource usages of MapReduce applications on multicore environment using tiling strategy.
* [http://ipads.se.sjtu.edu.cn/lib/exe/fetch.php?media=publications:ostrich-taco13.pdf "Tiled MapReduce: Efficient and Flexible MapReduce Processing on Multicore with Tiling"]—paper by Rong Chen, and Haibo Chen from [[Shanghai Jiao Tong University]]; published in ACM TACO, 10(1), 2013. It extends the earlier version of Ostrich to support several usage scenarios such as online and incremental computing on multicore machines.
* [http://dx.doi.org/10.1016/j.jpdc.2010.12.004 "Scheduling divisible MapReduce computations "]—paper by Joanna Berlińska from [[Adam Mickiewicz University]] and Maciej Drozdowski from [[Poznan University of Technology]]; Journal of Parallel and Distributed Computing 71 (2011) 450-459, {{doi|10.1016/j.jpdc.2010.12.004}}. It presents scheduling and performance model of MapReduce.
* [http://stratosphere.eu/files/NephelePACTs_10.pdf "Nephele/PACTs: A Programming Model and Execution Framework for Web-Scale Analytical Processing"]—paper by D. Battré, S. Ewen, F. Hueske, O. Kao, V. Markl, and D. Warneke from [http://www.tu-berlin.de/menue/home/parameter/en/ TU Berlin] published in Proc. of ACM SoCC 2010. The paper introduces the PACT programming model, a generalization of MapReduce, developed in the [http://www.stratosphere.eu Stratosphere] research project.
* [http://stratosphere.eu/files/ComparingMapReduceAndPACTs_11.pdf "MapReduce and PACT - Comparing Data Parallel Programming Models"]—paper by A. Alexandrov, S. Ewen, M. Heimel, F. Hueske, O. Kao, V. Markl, E. Nijkamp, and D. Warneke from [http://www.tu-berlin.de/menue/home/parameter/en/ TU Berlin] published in Proc. of BTW 2011.

{{Refend}}

; Books
{{Refbegin}}
* Jimmy Lin and Chris Dyer. [http://www.umiacs.umd.edu/~jimmylin/book.html "Data-Intensive Text Processing with MapReduce"] (manuscript)
{{Refend}}

;Educational courses

{{Refbegin}}
*[http://code.google.com/edu/submissions/mapreduce-minilecture/listing.html Cluster Computing and MapReduce] course from [http://code.google.com/edu/ Google Code University] contains video lectures and related course materials from a series of lectures that was taught to Google software engineering interns during the Summer of 2007.
* [http://code.google.com/edu/submissions/mapreduce/listing.html MapReduce in a Week] course from [http://code.google.com/edu/ Google Code University] contains a comprehensive introduction to MapReduce including lectures, reading material, and programming assignments.
* [http://mr.iap.2008.googlepages.com/ MapReduce course], taught by engineers of [[Google]] Boston, part of 2008 Independent Activities Period at [[MIT]].
{{Refend}}

; Bibliography
{{Refbegin}}
* [http://www.columbia.edu/~ak2834/mapreduce.html MapReduce bibliography by A. Kamil, 2010] 
{{Refend}}

{{DEFAULTSORT:Mapreduce}}
[[Category:Google software]]
[[Category:Parallel computing]]
[[Category:Distributed computing architecture]]</text>
      <sha1>i7zzblxnynwe9u1tynl16j5swdzvb7g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>