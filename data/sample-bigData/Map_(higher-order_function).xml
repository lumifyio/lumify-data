<?xml version="1.0" ?><page xmlns="http://www.mediawiki.org/xml/export-0.8/" version="0.8">
    <title>Map (higher-order function)</title>
    <ns>0</ns>
    <id>6045801</id>
    <revision>
      <id>562211453</id>
      <parentid>562154785</parentid>
      <timestamp>2013-06-30T06:51:11Z</timestamp>
      <contributor>
        <username>Greenrd</username>
        <id>15476</id>
      </contributor>
      <minor></minor>
      <comment>added category</comment>
      <text xml:space="preserve">{{single source|date=November 2012}}
In many [[programming language]]s, &lt;code&gt;'''map'''&lt;/code&gt; is the name of a [[higher-order function]] that applies a given [[Procedural parameter|function]] to each element of a [[list (computing)|list]], returning a list of results.  It is often called ''apply-to-all'' when considered in [[functional form]].  This is an example of [[homomorphism]]. &lt;!-- ex, map f = foldr ((:) . f) [] --&gt; 

For example, if we define a function &lt;code&gt;square&lt;/code&gt; as follows:

&lt;source lang="haskell"&gt;
square y = x * x
&lt;/source&gt;

Then calling &lt;code&gt;map square [1,2,3,4,5]&lt;/code&gt; will return &lt;code&gt;[1,4,9,16,25]&lt;/code&gt;, as &lt;code&gt;map&lt;/code&gt; will go through the list and apply the function &lt;code&gt;square&lt;/code&gt; to each element.

==Generalization==
In the [[Haskell (programming language)|Haskell programming language]], the [[Type polymorphism|polymorphic]] function &amp;nbsp;&lt;code&gt;map :: (a -&gt; b) -&gt; [a] -&gt; [b]&lt;/code&gt; is generalized to a [[Polytypic function|polytypic]] function called &lt;code&gt;fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b&lt;/code&gt;, which applies to any type in the [[functor (category theory)|&lt;code&gt;Functor&lt;/code&gt;]] class.

''map'' is used in Haskell's Prelude to define the list type constructor (&lt;code&gt;[]&lt;/code&gt;) an instance of the &lt;code&gt;Functor&lt;/code&gt; type class as follows 
&lt;source lang="haskell"&gt;
 instance Functor [] where fmap = map
&lt;/source &gt;

But trees may belong to &lt;code&gt;Functor&lt;/code&gt; too, for example:
&lt;source lang="haskell"&gt;
 data Tree a = Leaf a | Fork (Tree a) (Tree a)
 instance Functor Tree where  
   fmap f (Leaf x) = Leaf (f x)
   fmap f (Fork l r) = Fork (fmap f l) (fmap f r)

 fmap (1+) (Fork(Fork(Leaf 0)(Leaf 1))(Fork(Leaf 2)(Leaf 3)))
&lt;/source &gt;
evaluates to:

&lt;source lang="haskell"&gt;
 Fork (Fork(Leaf 1)(Leaf 2))(Fork(Leaf 3)(Leaf 4))
&lt;/source &gt;

For every instance of the &lt;code&gt;Functor&lt;/code&gt; [[type class]], &lt;code&gt;fmap&lt;/code&gt; is expected to be defined such that it obeys the functor laws:
&lt;source lang="haskell"&gt;
fmap id = id -- identity
fmap (f . g) = fmap f . fmap g -- composition
&lt;/source &gt;

Among other uses, this allows defining element-wise operations for various kinds of [[collection (computer science)|collections]].  

Moreover, if &lt;math&gt;F&lt;/math&gt; and &lt;math&gt;G&lt;/math&gt; are two functors, a [[natural transformation]] is a function of polymorphic type &lt;math&gt;h: \, \forall T.\, F \, T \rarr G \, T&lt;/math&gt; which respects ''fmap'':
:&lt;math&gt;h_{Y} \circ (\mathrm{fmap} \, k) = (\mathrm{fmap} \, k) \circ h_{X}&lt;/math&gt; for any function &lt;math&gt;k: X \rarr Y&lt;/math&gt;.

If the ''h'' function is defined by [[parametric polymorphism]] as in the type definition above, this specification is always satisfied.

==Optimizations==
The mathematical basis of maps allow for a number of [[Optimization (computer science)|optimizations]]. If one has &lt;code&gt;(map f . map g) xs&lt;/code&gt; ('.' is [[function composition (computer science)|function composition]]) then it is the same as the simpler &lt;code&gt;map (f . g) xs&lt;/code&gt;; that is,
&lt;math&gt;\left( \text{map}\,f \right) \circ \left( \text{map}\,g \right) = \text{map}\,\left( f \circ g \right)&lt;/math&gt;. This particular optimization eliminates an expensive second map by fusing it with the first map; thus it is a "map fusion".&lt;ref&gt;[http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance "Map fusion: Making Haskell 225% faster"]&lt;/ref&gt;

Map functions can be and often are defined in terms of a [[Fold (higher-order function)|fold]] such as &lt;code&gt;foldr&lt;/code&gt;, which means one can do a "map-fold fusion": &lt;code&gt;foldr f z . map g&lt;/code&gt; is equivalent to &lt;code&gt;foldr (f . g) z&lt;/code&gt;.

The implementation of map above on singly linked lists is not [[tail recursion|tail-recursive]], so may build up a lot of frames on the stack when called with a large list. Many languages alternately provide a "reverse map" function, which is equivalent to reversing a mapped list, but is tail-recursive. Here is an implementation which utilizes the [[fold (higher-order function)|fold]]-left function.

&lt;source lang="haskell"&gt;
 rev_map f = foldl (\ys x -&gt; f x : ys) []
&lt;/source&gt;

Since reversing a singly linked list is also tail-recursive, reverse and reverse-map can be composed to perform normal map in a tail-recursive way.

==Language comparison==
The map function originated in [[functional programming]] languages but is today supported (or may be defined) in many [[procedural programming|procedural]], [[object oriented]], and [[multi-paradigm]] languages as well: In [[C++]]'s [[Standard Template Library]], it is called &lt;code&gt;transform&lt;/code&gt;, in C# (3.0)'s LINQ library, it is provided as an extension method called &lt;code&gt;Select&lt;/code&gt;. Map is also a frequently used operation in high level languages such as [[Perl]], [[Python (programming language)|Python]] and [[Ruby (programming language)|Ruby]]; the operation is called &lt;code&gt;map&lt;/code&gt; in all three of these languages. A &lt;code&gt;collect&lt;/code&gt; alias for &lt;code&gt;map&lt;/code&gt; is also provided in Ruby (from [[Smalltalk]]). [[Common Lisp]] provides a family of map-like functions; the one corresponding to the behavior described here is called &lt;code&gt;mapcar&lt;/code&gt; (&lt;code&gt;-car&lt;/code&gt; indicating access using the [[CAR and CDR|CAR operation]]). There are also languages with syntactic constructs providing the same functionality as the map function.

Map is sometimes generalized to accept dyadic (2-argument) functions that can apply a user-supplied function to corresponding elements from two lists; some languages use special names for this, such as ''map2'' or ''zipWith''. Languages using explicit [[variadic function]]s may have versions of map with variable [[arity]] to support ''variable-arity'' functions. Map with 2 or more lists encounters the issue of handling when the lists are of different lengths. Various languages differ on this; some raise an exception, some stop after the length of the shortest list and ignore extra items on the other lists; some continue on to the length of the longest list, and for the lists that have already ended, pass some placeholder value to the function indicating no value.

In languages which support [[first-class function]]s, map may be [[partial application|partially applied]] to "lift" functions to element-wise versions; for instance, &lt;code&gt;(map square)&lt;/code&gt; is a Haskell function which squares lists element-wise.

{| class="wikitable"
|+ Map in various languages
! Language !! Map !! Map 2 lists !! Map n lists !! Notes !! Handling lists of different lengths
|-
| [[Common Lisp]]
| (mapcar ''func'' ''list'')
| (mapcar ''func'' ''list1'' ''list2'')
| (mapcar ''func'' ''list1'' ''list2'' ...)
|
| stops after the length of the shortest list
|-
| [[C++]]
| std::transform(''begin'', ''end'', ''result'', ''func'')
| std::transform(''begin1'', ''end1'', ''begin2'', ''result'', ''func'')
|
| in header &lt;algorithm&gt;&lt;br /&gt; ''begin'', ''end'', &amp; ''result'' are iterators&lt;br /&gt; result is written starting at ''result''
|
|-
| [[C Sharp (programming language)|C#]] 3.0
| ''ienum''.Select(''func'')
|
|
| Select is an extension method&lt;br /&gt; ''ienum'' is an IEnumerable&lt;br /&gt; Similarly in all .NET languages
|
|-
| [[C Sharp (programming language)|C#]] 4.0
| ''ienum''.Select(''func'')
| ''ienum1''.Zip(''ienum2'', ''func'')
|
| Select is an extension method&lt;br /&gt; ''ienum'' is an IEnumerable&lt;br /&gt; Similarly in all .NET languages
| stops after the shortest list ends
|-
| [[Erlang (programming language)|Erlang]]
| lists:map(''Fun'', ''List'')
| lists:zipwith(''Fun'', ''List1'', ''List2'')
|
| ''zipwith3'' also available
| Lists must be equal length
|-
| [[Haskell (programming language)|Haskell]]
| map ''func'' ''list''
| zipWith ''func'' ''list1'' ''list2''
| zipWith''n'' ''func'' ''list1'' ''list2'' ...
| ''n'' corresponds to the number of lists; predefined up to ''zipWith7''
| stops after the shortest list ends
|-
| [[Groovy (programming language)|Groovy]]
| list.collect(lambda)
| 
| 
| 
| 
|-
| [[haXe]]
| Lambda.map(''iterable'', ''func'')
| 
| 
| 
| 
|-
| [[J (programming language)|J]]
| ''func'' ''list''
| ''list'' ''func'' ''list''
| ''func''/ ''list1'', ''list2'', ''list3'', : ''list4''
| J's array processing capabilities make operations like map implicit
| length error if lists not equal
|-
| [[JavaScript]] 1.6
| [https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map ''array''.map(''func'')]
| ''List1''.map(function (elem1, i) { &lt;br /&gt;return ''func''(elem1, ''List2''[i]); })
| ''List1''.map(function (elem1, i) { &lt;br /&gt;return ''func''(elem1, ''List2''[i], ''List3''[i], ...); })
| Array.map passes 3 arguments to ''func'': the element, the index of the element, and the array.  Unused arguments can be omitted.
| Stops at the end of ''List1'', extending the shorter arrays with ''undefined'' items if needed.
|-
| [[Logtalk]]
| map(''Closure'', ''List'')
| map(''Closure'', ''List1'', ''List2'')
| map(''Closure'', ''List1'', ''List2'', ''List3'', ...) (up to seven lists)
| Only the ''Closure'' argument must be instantiated.
| Failure
|-
| [[Mathematica]]
| ''func'' /@ ''list'' &lt;br /&gt; Map[''func'', ''list'']
| MapThread[''func'', {''list1'', ''list2''}]
| MapThread[''func'', {''list1'', ''list2'', ...}]
|
| Lists must be same length
|-
| [[Maxima (software)|Maxima]]
| map(''f'', ''expr&lt;sub&gt;1&lt;/sub&gt;'', ..., ''expr&lt;sub&gt;n&lt;/sub&gt;'')&lt;br /&gt;maplist(''f'', ''expr&lt;sub&gt;1&lt;/sub&gt;'', ..., ''expr&lt;sub&gt;n&lt;/sub&gt;'')
|
|
| map returns an expression whose leading operator is the same as that of the expressions;&lt;br /&gt;maplist returns a list
|
|-
| [[OCaml]]
| List.map ''func'' ''list''&lt;br /&gt; Array.map ''func'' ''array''
| List.map2 ''func'' ''list1'' ''list2''
|
| 
| raises Invalid_argument exception
|-
| [[PARI/GP]]
| apply(''func'', ''list'')
|
|
| 
| N/A
|-
| [[Perl]]
| map ''block'' ''list''&lt;br /&gt; map ''expr'', ''list''
|
|
| In ''block'' or ''expr'' special variable ''$_'' holds each value from list in turn.
| Helper ''List::MoreUtils::each_array'' combines more than one list until the longest one is exhausted, filling the others with ''undef''.
|-
| [[PHP]]
| array_map(''callback'', ''array'')
| array_map(''callback'', ''array1'',''array2'')
| array_map(''callback'', ''array1'',''array2'', ...)
| The number of parameters for ''callback''&lt;br /&gt;should match the number of arrays.
| extends the shorter lists with ''NULL'' items
|-
| [[Prolog]]
| maplist(''Cont'', ''List1'', ''List2'').
| maplist(''Cont'', ''List1'', ''List2'', ''List3'').
| maplist(''Cont'', ''List1'', ''...'').
| List arguments are input, output or both. Subsumes also zipWith, unzip, all
| Silent failure (not an error)
|-
| [[Python (programming language)|Python]]
| map(''func'', ''list'')
| map(''func'', ''list1'', ''list2'')
| map(''func'', ''list1'', ''list2'', ...)
| Returns a list in Python 2 and an [[iterator]] in Python 3.
| ''zip()'' and ''map()'' (3.x) stops after the shortest list ends, whereas ''map()'' (2.x) and ''itertools.zip_longest()'' (3.x) extends the shorter lists with ''None'' items
|-
| [[Racket (programming language)|Racket]]
| (map ''func'' ''list'')
| (map ''func'' ''list1'' ''list2'')
| (map ''func'' ''list1'' ''list2'' ...)
|
| lists must all have the same length
|-
| [[Ruby (programming language)|Ruby]]
| ''enum''.collect {''block''}&lt;br /&gt; ''enum''.map {''block''}
| ''enum1''.zip(''enum2'').map {''block''}
| ''enum1''.zip(''enum2'', ...).map {''block''} &lt;br /&gt; [''enum1'', ''enum2'', ...].transpose.map {''block''}
| ''enum'' is an Enumeration
| stops at the end of the object it is called on (the first list); if any other list is shorter, it is extended with ''nil'' items
|-
| [[S (programming language)|S]]/[[R (programming language)|R]]
| lapply(''list'',''func'')
| mapply(''func'',''list1'',''list2'')
| mapply(''func'',''list1'',''list2'',...)
|
| Shorter lists are cycled
|-
| [[Scala (programming language)|Scala]]
| ''list''.map(''func'')
| (''list1'', ''list2'').zipped.map(''func'')
| (''list1'', ''list2'', ''list3'').zipped.map(''func'')
| note: more than 3 not possible.
| stops after the shorter list ends
|-
| [[Scheme (programming language)|Scheme]], [[Clojure]]
| (map ''func'' ''list'')
| (map ''func'' ''list1'' ''list2'')
| (map ''func'' ''list1'' ''list2'' ...)
|
| Scheme: lists must all have same length &lt;br/&gt; Clojure: stops after the shortest list ends
|-
| [[Smalltalk]]
| ''aCollection'' collect: ''aBlock''
| ''aCollection1'' with: ''aCollection2'' collect: ''aBlock''
|
|
| Fails
|-
| [[Standard ML]]
| map ''func'' ''list''
| ListPair.map ''func'' (''list1'', ''list2'') &lt;br /&gt; ListPair.mapEq ''func'' (''list1'', ''list2'')
|
| For 2-argument map, ''func'' takes its arguments in a tuple
| ''ListPair.map'' stops after the shortest list ends, whereas ''ListPair.mapEq'' raises UnequalLengths exception
|}

==See also==
* [[Filter (higher-order function)]]
* [[List comprehension]]
* [[foreach]]
* [[Fold (higher-order function)]]
* [[Convolution (computer science)]], (also known as ''conv'' or ''zip'')
* [[Free monoid]]
* [[MapReduce]]

==References==
&lt;References/&gt;

[[Category:Higher-order functions]]
[[Category:Programming language comparisons]]
[[Category:Articles with example Haskell code]]
[[Category:Iteration in programming]]</text>
      <sha1>5ft3qsvsvidl9wqs2hzj7u1ekdnok3n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>