<?xml version="1.0" ?><page xmlns="http://www.mediawiki.org/xml/export-0.8/" version="0.8">
    <title>View (database)</title>
    <ns>0</ns>
    <id>1960226</id>
    <revision>
      <id>562215874</id>
      <parentid>562215841</parentid>
      <timestamp>2013-06-30T07:49:22Z</timestamp>
      <contributor>
        <username>Matinict</username>
        <id>19079677</id>
      </contributor>
      <comment>/* MySQL view */</comment>
      <text xml:space="preserve">In [[database theory]], a '''view''' is the [[result set]] of a ''stored'' [[Query language|query]] &amp;mdash; or [[map (higher-order function)|map]]-and-[[fold (higher-order function)|reduce]] functions &amp;mdash; on the [[data]], which the [[database]] users can query just as they would a persistent database collection object. This pre-established query command is kept in the database dictionary. Unlike ordinary ''base tables'' in a [[relational database]], a view does not form part of the [[database design|physical schema]]: as a result set, it is a virtual table computed or collated from data in the database, dynamically when access to that view is requested. Changes applied to the data in a relevant ''underlying table'' are reflected in the data shown in subsequent invocations of the view. In some [[NoSQL]] databases, views are the only way to query data.

Views can provide advantages over tables:
* Views can represent a subset of the data contained in a table; consequently, a view can limit the degree of exposure of the underlying tables to the outer world: a given user may have permission to query the view, while denied access to the rest of the base table.
* Views can [[Join (SQL)|join]] and simplify multiple tables into a single virtual table
* Views can act as aggregated tables, where the [[database engine]] aggregates data ([[sum]], [[average]] etc.) and presents the calculated results as part of the data
* Views can hide the complexity of data; for example a view could appear as Sales2000 or Sales2001, transparently [[Partition (database)|partitioning]] the actual underlying table
* Views take very little space to store; the database contains only the definition of a view, not a copy of all the data which it presents
* Depending on the [[SQL]] engine used, views can provide extra security

Just as a [[function (computing)|function]] (in programming) can provide [[Abstraction (computer science)|abstraction]], so can a database view. In another parallel with functions, database users can manipulate nested views, thus one view can aggregate data from other views. Without the use of views, the [[Database normalization|normalization]] of databases above [[second normal form]] would become much more difficult. Views can make it easier to create lossless join decomposition.

Just as [[Row (database)|rows]] in a base table lack any defined ordering, rows available through a view do not appear with any default sorting.  A view is a relational table, and the relational model defines a table as a set of rows. Since sets are not ordered - by definition - nor are the rows of a view. Therefore, an [[order by (SQL)|ORDER BY]] clause in the view definition is meaningless; the SQL standard ([[SQL:2003]]) does not allow an ORDER BY clause in the subquery of a CREATE VIEW command, just as it is refused in a CREATE TABLE statement. However, sorted data can be obtained from a view, in the same way as any other table &amp;mdash; as part of a query [[Statement (programming)|statement]] on that view. Nevertheless, some DBMS (such as [[Oracle Database]]) do not abide by this SQL standard restriction.

== Read-only vs. updatable views ==
Database practitioners can define views as [[file system permissions|read-only]] or updatable.  If the database system can determine the reverse mapping from the view schema to the schema of the underlying base tables, then the view is updatable.  [[Insert (SQL)|INSERT]], [[Update (SQL)|UPDATE]], and [[Delete (SQL)|DELETE]] operations can be performed on updatable views.  Read-only views do not support such operations because the DBMS cannot map the changes to the underlying base tables.  A view update is done by key preservation.

Some systems support the definition of INSTEAD OF [[Database trigger|triggers]] on views.  This technique allows the definition of other logic for execution in place of an insert, update, or delete operation on the views.  Thus database systems can implement data modifications based on read-only views. However, an INSTEAD OF trigger does not change the read-only or updatable property of the view itself.

==Advanced view features ==
Various [[database management system]]s have extended the views from read-only subsets of [[data]]. 

[[Oracle Database]] introduced the concept of [[materialized view]]s: pre-executed, non-virtual views commonly used in [[Data warehouse|data warehousing]]. They give a static snapshot of the data and may include data from remote sources. The accuracy of a materialized view depends on the frequency of trigger mechanisms behind its updates. [[IBM DB2]] provides so-called "materialized query tables" (MQTs) for the same purpose. [[Microsoft SQL Server]] introduced in its 2000 version indexed views which only store a separate index from the table, but not the entire data.

== Equivalence ==

A view is equivalent to its source query. When queries are run against views, the query is modified. For example, if there exists a view named accounts_view with the content as follows:

&lt;pre&gt;
accounts_view:
-------------
SELECT name,
       money_received,
       money_sent,
       (money_received - money_sent) AS balance,
       address,
	   ...
  FROM table_customers c 
  JOIN accounts_table a 
    ON a.customer_id = c.customer_id
&lt;/pre&gt;

then the application could run a simple query such as:

&lt;pre&gt;
Simple query
------------
SELECT name,
       balance
  FROM accounts_view
&lt;/pre&gt;

The RDBMS then takes the simple query, replaces the equivalent view, then sends the following to the [[query optimizer]]:

&lt;pre&gt;
Preprocessed query:
------------------
SELECT name,
       balance
  FROM (SELECT name,
               money_received,
               money_sent,
               (money_received - money_sent) AS balance,
               address,
			    ...
          FROM table_customers c JOIN accounts_table a
               ON a.customer_id = c.customer_id        )
&lt;/pre&gt;

From this point on the optimizer takes the query, removes unnecessary complexity (for example: it is not necessary to read the address, since the parent invocation does not make use of it) and then sends the query to the SQL engine for processing.

== MySQL view == 
View is virtual table in [[database]].
&lt;source lang="MySQL"&gt;
--  CREATE VIEW Syntax:

CREATE VIEW MyDB.MyView AS SELECT * FROM MyDB_Table;
&lt;/source&gt;

== See also ==
* [[Bidirectionalization]]

== External links ==
* [http://publib.boulder.ibm.com/infocenter/dzichelp/v2r2/index.jsp?topic=/com.ibm.db2z10.doc.intro/src/tpc/db2z_typesoftables.htm Materialized query tables in DB2]
* [http://msdn.microsoft.com/en-us/library/ms187956.aspx Views in Microsoft SQL Server]
* [http://dev.mysql.com/doc/refman/5.1/en/views.html Views in MySQL]
* [http://www.postgresql.org/docs/current/interactive/tutorial-views.html Views in PostgreSQL]
* [http://www.sqlite.org/lang_createview.html Views in SQLite]
* [http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/statements_8004.htm#SQLRF01504 Views in Oracle 11.2]
* [http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views Views in CouchDB]
* [http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/statements_6002.htm#SQLRF01302 Materialized Views in Oracle 11.2]

{{Databases}}

{{DEFAULTSORT:View (Database)}}
[[Category:Database management systems]]
[[Category:SQL]]
[[Category:Database theory]]</text>
      <sha1>1zy6mg5w63ca3dpv9wvtbat3fboldf0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>